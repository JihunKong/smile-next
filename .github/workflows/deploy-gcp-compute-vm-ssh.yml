name: Deploy to GCP Compute VM via SSH

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      port:
        required: true
        type: string
      docker-tag:
        required: true
        type: string
      container-name:
        required: true
        type: string
      image-name:
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Verify build succeeded
        run: |
          echo "‚úÖ Build verification passed - proceeding with deployment"

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Prepare Deployment Directory
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 10s
          script: |
            echo "üîß Preparing deployment directory..."
            echo "Current user: $(whoami)"
            echo "Home directory: $HOME"
            
            # Prepare user home directory
            echo "üìÅ Preparing $HOME/smile-next..."
            mkdir -p "$HOME/smile-next"
            # Only remove scripts directory, preserve .env and other files
            echo "üîí Preserving .env file and other non-script files..."
            rm -rf "$HOME/smile-next/scripts" 2>/dev/null || true
            
            # Verify .env file is preserved (if it exists)
            if [ -f "$HOME/smile-next/.env" ]; then
              echo "‚úÖ Found .env file in $HOME/smile-next (will be preserved)"
            fi

      - name: Copy Deploy Scripts and Docker Compose Files to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "scripts,docker-compose.dev.yml,docker-compose.prod.yml"
          target: "~/smile-next"
          rm: false
          debug: true
      
      - name: Setup Systemd Service (if needed)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 30s
          script: |
            # Find project directory
            PROJECT_DIR=""
            for dir in "$HOME/smile-next" "/opt/smile-next" "/opt/smile/app"; do
              if [ -d "$dir" ] && [ -f "$dir/docker-compose.dev.yml" ] || [ -f "$dir/docker-compose.prod.yml" ]; then
                PROJECT_DIR="$dir"
                break
              fi
            done
            
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ö†Ô∏è  Warning: Could not find project directory, skipping systemd setup"
              exit 0
            fi
            
            cd "$PROJECT_DIR" || { echo "ERROR: Cannot cd to $PROJECT_DIR"; exit 1; }
            
            ENVIRONMENT="${{ inputs.environment }}"
            if [ "$ENVIRONMENT" == "dev" ]; then
              COMPOSE_FILE="docker-compose.dev.yml"
              SERVICE_NAME="smile-next-dev"
            else
              COMPOSE_FILE="docker-compose.prod.yml"
              SERVICE_NAME="smile-next-prod"
            fi
            
            # Check if systemd service already exists
            if [ ! -f "/etc/systemd/system/${SERVICE_NAME}.service" ]; then
              echo "üîß Setting up systemd service for $SERVICE_NAME..."
              echo "   Project directory: $PROJECT_DIR"
              echo "   Compose file: $COMPOSE_FILE"
              bash scripts/deploy/setup-systemd-service.sh "$ENVIRONMENT" "$COMPOSE_FILE" "$SERVICE_NAME" || {
                echo "‚ö†Ô∏è  Warning: Failed to setup systemd service (may need manual setup)"
              }
            else
              echo "‚úÖ Systemd service $SERVICE_NAME already exists"
              echo "üîÑ Reloading systemd daemon to pick up any changes..."
              sudo systemctl daemon-reload || true
            fi

      - name: Validate Environment Configuration
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 10s
          script: |
            cd "$HOME/smile-next" || { echo "ERROR: $HOME/smile-next not found"; exit 1; }
            bash scripts/deploy/validate-env.sh ${{ inputs.environment }}

      - name: Deploy to VM via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 120s
          script: |
            # Find project directory (check multiple locations)
            PROJECT_DIR=""
            for dir in "$HOME/smile-next" "/opt/smile-next" "/opt/smile/app"; do
              if [ -d "$dir" ]; then
                PROJECT_DIR="$dir"
                break
              fi
            done
            
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: Could not find project directory"
              exit 1
            fi
            
            cd "$PROJECT_DIR" || { echo "ERROR: Cannot cd to $PROJECT_DIR"; exit 1; }
            echo "üìÅ Using project directory: $PROJECT_DIR"
            
            # Select docker-compose file based on environment
            ENVIRONMENT="${{ inputs.environment }}"
            if [ "$ENVIRONMENT" == "dev" ]; then
              COMPOSE_FILE="docker-compose.dev.yml"
              echo "üìã Using docker-compose.dev.yml (includes PostgreSQL + Redis)"
            else
              COMPOSE_FILE="docker-compose.prod.yml"
              echo "üìã Using docker-compose.prod.yml (Redis only, uses GCP Cloud SQL)"
            fi
            
            # Verify docker-compose file exists
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "‚ùå ERROR: $COMPOSE_FILE not found in $PROJECT_DIR"
              exit 1
            fi
            
            # Log in to GHCR
            echo "üîê Logging in to GitHub Container Registry..."
            echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || 'tedahn-pknic' }}" --password-stdin || {
              echo "‚ö†Ô∏è  Warning: Failed to login to GHCR"
            }
            
            # Pull the image
            IMAGE_TAG="${{ inputs.image-name }}:${{ inputs.docker-tag }}"
            echo "üì• Pulling Docker image: $IMAGE_TAG"
            docker pull "$IMAGE_TAG" || {
              echo "‚ùå Failed to pull image: $IMAGE_TAG"
              exit 1
            }
            
            # Tag the image for docker-compose
            docker tag "$IMAGE_TAG" "${{ inputs.image-name }}:latest" || true
            
            # Set environment variables for docker-compose
            export DOCKER_IMAGE="$IMAGE_TAG"
            export PORT="${{ inputs.port }}"
            export CONTAINER_NAME="${{ inputs.container-name }}"
            
            # Ensure volumes exist (for first-time setup) - this won't recreate existing volumes
            echo "üì¶ Ensuring volumes exist (data will be preserved)..."
            docker volume create app_redis_data 2>/dev/null || echo "‚úÖ Volume app_redis_data already exists (data preserved)"
            
            # For dev environment, also ensure PostgreSQL volume exists
            if [ "$ENVIRONMENT" == "dev" ]; then
              docker volume create app_postgres_data 2>/dev/null || echo "‚úÖ Volume app_postgres_data already exists (data preserved)"
            fi
            
            # IMPORTANT: Stop existing standalone containers FIRST to avoid conflicts
            # Then start them via docker-compose (using same volumes - data preserved)
            echo "üõë Stopping existing standalone containers (will restart via docker-compose)..."
            
            # Stop app container
            if docker ps -a | grep -q "${{ inputs.container-name }}"; then
              echo "   Stopping ${{ inputs.container-name }}..."
              docker stop "${{ inputs.container-name }}" 2>/dev/null || true
              docker rm "${{ inputs.container-name }}" 2>/dev/null || true
            fi
            
            # For dev: Stop standalone postgres/redis if they exist (will be managed by docker-compose)
            if [ "$ENVIRONMENT" == "dev" ]; then
              if docker ps -a | grep -q "smile-postgres"; then
                echo "   Stopping standalone smile-postgres (will restart via docker-compose with same volume)..."
                docker stop smile-postgres 2>/dev/null || true
                docker rm smile-postgres 2>/dev/null || true
              fi
            fi
            
            if docker ps -a | grep -q "smile-redis"; then
              echo "   Stopping standalone smile-redis (will restart via docker-compose with same volume)..."
              docker stop smile-redis 2>/dev/null || true
              docker rm smile-redis 2>/dev/null || true
            fi
            
            # Now start all services via docker-compose (using existing volumes - data preserved)
            echo "üöÄ Starting all services with docker-compose (using existing volumes - data preserved)..."
            if [ "$ENVIRONMENT" == "dev" ]; then
              # Dev: Start db, redis, and app
              docker-compose -f "$COMPOSE_FILE" up -d || {
                echo "‚ùå Failed to start services"
                exit 1
              }
              
              # Wait for dependencies to be healthy
              echo "‚è≥ Waiting for dependencies to be healthy..."
              sleep 5
              
              # Verify PostgreSQL is ready (dev only)
              for i in {1..20}; do
                if docker exec smile-postgres pg_isready -U smile_user -d smile_db > /dev/null 2>&1; then
                  echo "‚úÖ PostgreSQL is ready (data preserved from volume)"
                  break
                fi
                if [ $i -eq 20 ]; then
                  echo "‚ö†Ô∏è  PostgreSQL health check timeout (may still be starting)"
                fi
                sleep 1
              done
            else
              # Prod: Start redis and app (uses GCP Cloud SQL)
              docker-compose -f "$COMPOSE_FILE" up -d || {
                echo "‚ùå Failed to start services"
                exit 1
              }
              echo "‚è≥ Waiting for Redis to be ready..."
              sleep 3
            fi
            
            # Verify Redis is ready
            for i in {1..10}; do
              if docker exec smile-redis redis-cli ping > /dev/null 2>&1; then
                echo "‚úÖ Redis is ready (data preserved from volume)"
                break
              fi
              if [ $i -eq 10 ]; then
                echo "‚ö†Ô∏è  Redis health check timeout (may still be starting)"
              fi
              sleep 1
            done
            
            # Application is already started above with docker-compose up -d
            # Just ensure it's using the correct image
            echo "üîÑ Ensuring app container uses latest image..."
            ENV_FILE="$PROJECT_DIR/.env"
            if [ ! -f "$ENV_FILE" ]; then
              ENV_FILE="/opt/smile-next/.env"
            fi
            
            if [ -f "$ENV_FILE" ]; then
              set -a
              source "$ENV_FILE"
              set +a
            fi
            export DOCKER_IMAGE="$IMAGE_TAG"
            export CONTAINER_NAME="${{ inputs.container-name }}"
            export PORT="${{ inputs.port }}"
            
            # Recreate app container with new image
            docker-compose -f "$COMPOSE_FILE" up -d --force-recreate app || {
              echo "‚ùå Failed to recreate app container"
              exit 1
            }
            
            # Use systemd service to manage the entire stack (if available)
            SERVICE_NAME="smile-next-${ENVIRONMENT}"
            if systemctl list-unit-files | grep -q "^${SERVICE_NAME}.service"; then
              echo "üîÑ Reloading systemd service to ensure all containers are managed..."
              sudo systemctl daemon-reload || true
              # Restart the service to ensure all containers (db, redis, app) are running
              sudo systemctl restart "$SERVICE_NAME" || {
                echo "‚ö†Ô∏è  Warning: Failed to restart systemd service, but containers are running"
              }
              echo "‚úÖ Systemd service $SERVICE_NAME reloaded - now managing all containers"
            else
              echo "‚ÑπÔ∏è  Systemd service not found, containers managed directly by docker-compose"
              echo "üí° Consider running: bash scripts/deploy/setup-systemd-service.sh $ENVIRONMENT $COMPOSE_FILE $SERVICE_NAME"
            fi
            
            # Clean up old images
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -af --filter "until=24h" || echo "Image cleanup completed with warnings"
            
            echo "‚úÖ Deployment completed successfully!"

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 30s
          script: |
            cd "$HOME/smile-next" || { echo "ERROR: $HOME/smile-next not found"; exit 1; }
            export ENVIRONMENT="${{ inputs.environment }}"
            bash scripts/deploy/verify-deployment.sh "${{ inputs.container-name }}"
